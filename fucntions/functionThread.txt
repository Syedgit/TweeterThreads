
<<<<<<MAIN>>>>>>
Functions are one of the fundamental building blocks in JavaScript. 
A function in JavaScript is similar to a procedure—a set of statements that performs a task or calculates a value, but for a procedure to qualify as a function, it should take some input and return an output where there is some obvious relationship between the input and the output. To use a function, you must define it somewhere in the scope from which you wish to call it.

A function is a subprogram designed to perform a particular task.
Functions are executed when they are called. This is known as invoking a function.
Values can be passed into functions and used within the function.
Functions always return a value. In JavaScript, if no return value is specified, the function will return undefined.
Functions are objects.


<<<<<<<ONE>>>>>>>

There are a few different ways to define a function in JavaScript:

A Function Declaration defines a named function. 

To create a function declaration you use the function keyword followed by the name of the function. 

When using function declarations, the function definition is hoisted, thus allowing the function to be used before it is defined.

function name(parameters){
  statements
}
A Function Expressions defines a named or anonymous function. An anonymous function is a function that has no name. Function Expressions are not hoisted, and therefore cannot be used before they are defined. In the example below, we are setting the anonymous function object equal to a variable.

let name = function(parameters){
  statements
}
An Arrow Function Expression is a shorter syntax for writing function expressions. Arrow functions do not create their own this value.

let name = (parameters) => {
  statements
}

<<<<<<<TWO>>>>>>>
The function expression or anonymous function is the function that can be assigned as an expression and without any name. 
If you take a look at the below example, the function without a name is assigned to the variable add. You can use this variable add like any other functions later.

const add = function(a, b) {
    return a + b;
}

const result = add(10, 30);

console.log("result:::::" + result);

{{{{{CODE_IMAGE_anonympous_funciton}}}}}

<<<<<<<TWO>>>>>>>

If you’re new to JavaScript, you may have heard the terms parameters and arguments used interchangeably. 

While very similar, there is an important distinction to make between these two keywords.

Parameters are used when defining a function, they are the names created in the function definition. 

In fact, during a function definition, we can pass in up to 255 parameters! Parameters are separated by commas in the (). Here’s an example with two parameters — param1 & param2:

const param1 = true;
const param2 = false;
function twoParams(param1, param2){
  console.log(param1, param2);
}

<<<<<<<THREEE>>>>>>>

Invoking a Function.
Functions execute when the function is called. This process is known as invocation.
You can invoke a function by referencing the function name, followed by an open and closed parenthesis: ().

First, we’ll define a function named logIt. This function will take one parameter, name. When executed, the function will log that name back to the console:

function logIt(name){
  console.log(name);
}
// To invoke our function, we call it, while passing in the singular parameter. Here I am calling this function with the name Joe:

logIt('Joe');
// Joe
If your function has no parameters, you can invoke it with an empty set of parenthesis:

function logIt2(){
  console.log('The second one');
}
logIt2();
// The second one


<<<<<<<FOUR>>>>>>

Every function in JavaScript returns undefined unless otherwise specified.

Let’s test this by creating and invoking an empty function:

function test(){};
test();
// undefined

// Awesome, as expected, undefined is returned.

Now, we can customize what is returned in our function by using the return keyword followed by our return value. Take a look at the code below:

function test(){
  return true;
};
test();
// true

<<<<<<FIVE>>>>>>>

Function scope
Variables defined inside a function cannot be accessed from anywhere outside the function, 
Function can access all variables and functions defined inside the scope in which it is defined.

// The following variables are defined in the global scope
const num1 = 20;
const num2 = 3;
const name = 'Chamakh';

// This function is defined in the global scope
function multiply() {
  return num1 * num2;
}

multiply(); // Returns 60

// A nested function example
function getScore() {
  const num1 = 2;
  const num2 = 3;

  function add() {
    return `${name} scored ${num1 + num2}`;
  }

  return add();
}

getScore(); // Returns "Chamakh scored 5"

<<<<<<SIX>>>>>>>

Closures
Closures are one of the most powerful features of JavaScript. 
JavaScript allows for the nesting of functions and grants the inner function full access to all the variables and functions defined inside the outer Function

Outer function does not have access to the variables and functions defined inside the inner function. 

Also, since the inner function has access to the scope of the outer function, the variables and functions defined in the outer function will live longer than the duration of the outer function execution, if the inner function manages to survive beyond the life of the outer function. A closure is created when the inner function is somehow made available to any scope outside the outer function.

const pet = function (name) {   // The outer function defines a variable called "name"
  const getName = function () {
    // The inner function has access to the "name" variable of the outer function
    return name;
  }
  return getName; // Return the inner function, thereby exposing it to outer scopes
}
const myPet = pet('Vivie');

myPet(); // Returns "Vivie"

<<<<<<<SEVEN>>>>>>>

Arrow functions
An arrow function expression (also called a fat arrow to distinguish from a hypothetical -> syntax in future JavaScript) has a shorter syntax compared to function expressions and does not have its own this, arguments, super, or new.target. Arrow functions are always anonymous.

Two factors influenced the introduction of arrow functions: shorter functions and non-binding of this.

Shorter functions
In some functional patterns, shorter functions are welcome. Compare:

const a = [
  'Hydrogen',
  'Helium',
  'Lithium',
  'Beryllium'
];

const a2 = a.map(function(s) { return s.length; });

console.log(a2); // [8, 6, 7, 9]

const a3 = a.map((s) => s.length);

console.log(a3); // [8, 6, 7, 9]
Copy to Clipboard
No separate this
Until arrow functions, every new function defined its own this value (a new object in the case of a constructor, undefined in strict mode function calls, the base object if the function is called as an "object method", etc.). This proved to be less than ideal with an object-oriented style of programming.

function Person() {
  // The Person() constructor defines `this` as itself.
  this.age = 0;

  setInterval(function growUp() {
    // In nonstrict mode, the growUp() function defines `this`
    // as the global object, which is different from the `this`
    // defined by the Person() constructor.
    this.age++;
  }, 1000);
}

<<<<<<EIGHT>>>>>>

Function hoisting
The hoisting in Javascript is that all the variable and function declarations are placed at the top of the current scope while executing. 
If you take a look at the following example, 
the function add is defined at the bottom of the file yet it can be accessed at line number 5. This is because of function hoisting.

let a;

a = add(5, 10);

console.log("Result of the adding two number " + a)

function add(a, b) {
    return a + b;
}


Function hoisting only works with function declarations — not with function expressions. The code below will not work.

{{{{ADD CODE IMAGE fucntion_hoisting}}}}

<<<<<<<NINE>>>>>>>

The function can return another function and these inner functions either return the result or return nothing.
If you look at the below example functions the first one returns another function that has a console statement. 
You can call these with double Parentheses. The number of parentheses is directly proportional to the number of nested functions as in the fourth example.


// function returns function which prints name
function printName() {
    return function printMyName() {
        console.log("Bhargav Bachina")
    }
}

// how to call
printName()()

// function takes arguments returns function which takes arguments and returns name
function printNameWithParams(firstName) {
    return function printMyName(lastName) {
        console.log(firstName + " " + lastName)
    }
}

// how to call
printNameWithParams("fname")("lname")

// function takes arguments returns function which takes arguments and returns addition
function addition(a) {
    return function add(b) {
        return a + b;
    }
}

// how to call
addition(10)(50)

// // functions nesting can go deep
function outer() {
    return function inner1() {
        return function inner2() {
            return function inner3() {
                return function inner4() {
                    return "returned from the inner function 4"
                }
            }
        }
    }
}

// how to call
outer()()()()()

<<<<<TEN>>>>>
this keyword in functions
The understanding of the keyword thisis very important in Javascript. The keyword always refers to the context in that function is being executed. 
For example, the function is defined and executed in the global window context so this always refers to the window context here.

let a = 10;

function add() {
    let a = 20;
    let b = 100;
    console.log("Accessing context::::" + this.a)
    console.log("Accessing context::::" + this.b)
}

add()

That is the reason why when you execute the above function this.a always prints the variable a from the global context. 
You can assign some other values and test them out as below.
<<<<<KEY____TAKEWAYS>>>>>>>>

Key Takeaways.
This is a lot of information to digest. Here’s a list of the important stuff:

A function is a subprogram designed to perform a particular task.
Function definitions are hoisted — expressions are not.
Functions are executed when they are called. This is known as invoking a function.
Values can be passed into functions and used within the function. The name of the value is called a parameter. The actual value itself is called an argument.
Functions always return a value. In JavaScript, if no return value is specified, the function will return undefined by default.
Functions are objects.